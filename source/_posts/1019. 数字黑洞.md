---
title: 1019. 数字黑洞
date: 2016-07-15 23:00:28
tags: 
  - 数据结构
  - PAT
category: PAT(B)
---

题目
---
&emsp;&emsp;给定任一个各位数字不完全相同的4位正整数，如果我们先把4个数字按非递增排序，再按非递减排序，然后用第1个数字减第2个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的6174，这个神奇的数字也叫Kaprekar常数。

例如，我们从6767开始，将得到

&emsp;&emsp;&emsp;&emsp;7766 - 6677 = 1089
&emsp;&emsp;&emsp;&emsp;9810 - 0189 = 9621
&emsp;&emsp;&emsp;&emsp;9621 - 1269 = 8352
&emsp;&emsp;&emsp;&emsp;8532 - 2358 = 6174
&emsp;&emsp;&emsp;&emsp;7641 - 1467 = 6174
&emsp;&emsp;&emsp;&emsp;... ...

&emsp;&emsp;现给定任意4位正整数，请编写程序演示到达黑洞的过程。
<!-- more -->
输入格式：

&emsp;&emsp;输入给出一个(0, 10000)区间内的正整数N。

输出格式：

&emsp;&emsp;如果N的4位数字全相等，则在一行内输出“N - N = 0000”；否则将计算的每一步在一行内输出，直到6174作为差出现，输出格式见样例。注意每个数字按4位数格式输出。

输入样例1：

	6767
输出样例1：

	7766 - 6677 = 1089
	9810 - 0189 = 9621
	9621 - 1269 = 8352
	8532 - 2358 = 6174
输入样例2：

	2222
输出样例2：

	2222 - 2222 = 0000


分析
---

代码
---
```C++
#include <iostream>
#include <algorithm>
#include <cstdio>
using namespace std;

int main()
{
  int n,a[4];
  scanf("%d",&n); 
  int num1,num2,k=0;
  if((n/1000==n/100%10) && (n/1000==n/10%10) && (n/1000==n%10))//所有位相同  
    {  
        printf("%04d - %04d = 0000\n",n,n);  
        return 0;  
    }
  while(k!=6174) { 
      a[0] = n/1000;  
      a[1] = n/100%10;  
      a[2] = n/10%10;  
      a[3] = n%10;  
      sort(a, a+4);  
      num2 = a[0] * 1000 + a[1] * 100 + a[2] * 10 + a[3];  
      num1 = a[3] * 1000 + a[2] * 100 + a[1] * 10 + a[0];
      k = num1 - num2;
      printf("%04d - %04d = %04d\n",num1,num2,k);  
        n = k; 
  } 
  return 0;
} 
```