title: Solidity学习之智能合约介绍
date: 2016-11-09 18:53:12
tags: 
  - 智能合约
  - solidity
category: solidity
------

## 一个简单的智能合约
我们先从一个最基础的例子开始，如果你现在不能全部理解是没有关系的，后面我们会进行深入的学习。
### 存储（Storage）
```
pragma solidity ^0.4.0;

contract SimpleStorage {
    uint storedData;

    function set(uint x) {
        storedData = x;
    }

    function get() constant returns (uint retVal) {
        return storedData;
    }
}
```

我们可以简单的看出，第一行就是告诉我们这个源码是使用solidity编写，并且适用于0.4.0及新的版本（不超过0.5.0），这样是为了确保这个合约编译时不会突然产生歧义。

<!-- more -->

一个solidity合约是代码（合约的函数）和数据（合约的状态）的集合，它存在于以太坊区块链的一个特殊地址上。`uint storedData`表示定义了一个`uint`类型(256位的无符号整形)的`storedData`变量。你可以把它理解为是数据库里的一个存储单元，同数据库一样可以通过函数来查询或者更改它。而在以太坊中，只有合约的拥有者才可以这样做。`set`和`get`函数则是用来更改和获取变量的值。

与其他编程语言一样，在访问状态变量时，我们不需要使用`this.`这样的前缀。

这个合约还无法做很多的事（由于以太坊基础设施的构建限制），它只是允许某个人存储一个值，并且世界上任何一个人都可以获取到这个，所以暂时还缺少一种（可靠的）方式来保护你发布的这个值。当然，任何人都可以重复调用`set`函数来将原来的值覆盖，但是原来值依旧会存储在区块链的历史纪录里。之后，我们将学习如何填加一个访问限制使得只有你自己才能对这个值进行修改。
 
### 代币例子（Subcurrency Example）
下面的这个合约将实现一个最简单的货币加密形式。凭空生成硬币是可能的，但是仅仅只有创建这个合约的人才有可以做到（实行一个不同的发行方案是没有什么价值的）。此外，任何人可以进行交易而不需要注册用户名和密码，你需要的是以太坊的密钥对。
```solidity
pragma solidity ^0.4.0;

contract Coin {
    // "pubilic"关键字使得这些变量是可以从外部进行访问
    address public minter;
    mapping (address => uint) public balances;

    // 事件让轻客户端可以高效的对变化做出反应
    event Sent(address from, address to, uint amount);

    // 这是这个合约的构造函数，在合约创建的时候运行
    function Coin() {
        minter = msg.sender;
    }

    function mint(address receiver, uint amount) {
        if (msg.sender != minter) return;
        balances[receiver] += amount;
    }

    function send(address receiver, uint amount) {
        if (balances[msg.sender] < amount) return;
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        Sent(msg.sender, receiver, amount);
    }
}
```
这个合约介绍了一些新的概念，让我们一个一个的来学习。

`address public minter;`这一行申明了一个地址类型的公有状态变量，`adress`类型是一个不允许进行任何算术运算的160位的值。使用它来存储合约地址或者他人的密钥对是非常合适的。包含`public`关键字的函数允许你可以访问当前的状态变量的值。如果没有这个关键字，其他的合约就不能访问到这个变量，只有这个合约的代码可以对变量进行操作。这个函数将是这样：
```solidity
function minter() returns (address) { return minter; }
```
当然，如果我们这样添加编译器会报错，因为我们已经有了相同名字的函数和变量。

下一行`mapping (address => uint) public balances;`也是创建了一个共有的钻港台变量，但是它是一个更复杂的数据类型。这种类型将地址映射到一个无符号整形数。Mapping可以看作是一个被虚拟初始化的哈希表，每一个可能的key对应的值都被初始化为了0。这个比喻不是很合适，因为它既不能获得一个mapping的所有keys的列表，也不能获得所有value的列表。所以要记住（或者更好的话，使用列表或者更高级的数据类型）你添加了什么到这个映射中，或者在不受影响的场景中使用mapping，比如这个。这个例子中，`public`关键字创建的访问其函数会有一些复杂，它大致是下面这个样子：
```solidity
function balances(address _account) returns (uint balance) {
    return balances[_account];
}
```
正如你看到的，你可以使用这个函数来简单的查询单个账户的余额。

`event Sent(address from, address to, uint amount);`这一行声明了一个所谓的`event`，它会在代码的会由`send`函数的最后一行代码进行触发。用户界面（同时还有服务器设备）会监听这些在区块链上被触发的事件，而不需要太多的代价。当它被触发时，监听器会收到`from`,`to`和`amount`,可以方便的用于交易追踪。为了监听这个事件，你需要使用：
```solidity
Coin.Sent().watch({}, '', function(error, result) {
    if (!error) {
        console.log("Coin transfer: " + result.args.amount +
            " coins were sent from " + result.args.from +
            " to " + result.args.to + ".");
        console.log("Balances now:\n" +
            "Sender: " + Coin.balances.call(result.args.from) +
            "Receiver: " + Coin.balances.call(result.args.to));
    }
}
```
注意在用户界面是如何调用自动生成`balances`函数的。

这个特殊的函数`coin`是一个构造器，它会在合约创造的时候运行，并且之后不能调用。它会永久的存储合约创造者的地址，msg（以及tx和block）是一个神奇的全局变量包含一些可以被区块连访问的属性。`msg.sender` 则总是存放着当前函数的外部调用者的地址。

最后真正用来结束合约并且可以用户和合约调用的函数是`mint`和`send`。如果`mint`被除了创造合约的这个账户以外的任何人调用，什么都不会发生。另一方面，`send`可以被任何人（已经拥有一些硬币钱）使用来将钱转给其他人。注意如果你使用这个合约发送coin到其他地址，当你在去快链浏览器中查询该地址，你将什么都看不到，因为实际上你发送coin和余额的改变仅仅存储在该代币合约的数据存储中。通过使用事件我们可以很容易创建一个可以追踪你的新币交易和余额的“区块链浏览器”。

## 区块连基础（Blockchain Basics）
对于程序员来说，区块链的概念并不难理解。因为大多数应用（挖矿，哈希，椭圆曲线加密，点对点网络等等）只是为了提供一些特征和承诺。一旦你接受这些既有的特征，你不需要关心其底层的技术。就像你如果仅仅是为了使用亚马逊的AWS，而不需要了解其内部工作原理。

### 事务（Transactions）
区块链是一个全球共享的事务数据库。这意味着每个人都可以阅读数据库中的条目仅仅只需加入网络。如果你想改变数据库中的一些东西，你需要创建所谓的事务，它需要被所有其他人的确定。事务这个词意味着你要做的修改（假如你想同时修改两个值）只能被完完全全的实施或者什么都不做。此外，当你的事务被应用到了数据库之后，没有其他的事务可以再对它进行修改。

一个简单的例子，想象一张表中列出了所有账户的电子货币余额。如果有一个从一个账户到另一个账户的交易被请求，数据库的事务性确保了如果从一个帐户减去该金额，则它总是被添加到另一个帐户。如果处于某些原因，不可能向目标帐户添加金额，那么源帐户也不会被修改。

此外，一个事务总是由发送者（创建者）加密签名，这直接保护了对数据库特定修改的访问。 在电子货币的示例中，简单的验证确保只有持有账户密钥的人可以从其中转移货币。

### 区块
要克服的一个主要障碍是，在比特币的术语中，被称为“双花攻击（double-spend attack）”：如果网络中存在两个想要清空帐户的交易，即所谓的冲突，会发生什么？

对此的回答是，你不必关心。这些事务会排序之后被捆绑到所谓的“区块”中，然后它们将被执行并通知到所有参与节点。如果两个事务相互矛盾，那么最终第二个事务将被拒绝并且不会成为区块的一部分。

这些区块会在时间上形成线性序列，并且这就是为什么会叫"blockchain"。 区块会以一定规则的时间间隔添加到链中 - 对于Ethereum，这大约每17秒。

作为“顺序选择机制”（其被称为“挖矿”）的一部分，区块有可能会不时地被恢复，但它仅会在发生链的末端。 在端部添加的区块越多，其可能性就越小。 所以可能你的交易会被还原，甚至从区块链中删除，但等待的时间越长，这种情况就越不可能发生。

## 以太坊虚拟机（The Ethereum Virtual Machine）
### 概述

Ethereum虚拟机或EVM是以太坊中智能合约的运行时环境。 它不仅是一个沙箱，而且实际上是完全隔离的，这意味着在EVM内运行的代码无法访问网络，文件系统或其他进程。智能合约甚至限制了其他智能合约的使用。

### 账户
以太坊中有两种共享相同地址空间的帐户：由公钥-私钥对（即人类）控制的外部帐户和由与帐户一起存储的代码控制的合约帐户。。

外部帐户的地址是由公钥确定，合约账户的地址是创建合约时确定的（它由创建者地址和从该地址发送的事务的数量而计算而得，即所谓的“ nonce“）。

除了帐户是否存储代码之外，这两种类型账户对于EVM来说是一样的。

每个帐户都有一个持久的键值（key-value）存储，key和value的长度都是256位的，它称为"storage"。

此外，每个帐户在中都有一个以太币Ether（单位是“Wei”）余额，可以通过发送包含以太币的交易来进行修改。

### 事务（Transactions）
事务是从一个帐户发送到另一个帐户（可能是相同的或特殊的零帐户，见下文）的消息。 它可以包括二进制数据（payload ）和以太币（Ether）。

如果目标帐户包含代码，那么将执行该代码，并将有效内容作为输入数据。

如果目标帐户是零帐户（地址为0的帐户），则事务会创建一个新合约。正如上面所说，该合约的地址不是零地址，而是从发送方及其发送的事务数量计算而出的地址（“nonce”）。创建合约交易的payload被当作EVM字节码执行。此执行的输出将作为合约的代码被永久存储。这意味着，为了创建合约，你不需要发送真正的合约代码，而是发送能够返回真正代码的代码。

### Gas
在创建时，每个交易被需要收取一定量的gas，其目的是限制执行交易所需的工作量并支付该次执行的花费代价。当EVM执行事务时，gas会根据特定规则逐渐消耗。

**gas price**的值是由事务的创建者设定的，发送账户需要预付的交易费用为`gas_price * gas` .如果在执行事务后gas 有剩余，则会以相同的方式退还给发送账户。

如果gas在任何点被用尽（即它是负的），则触发out-of-gas异常，当前调用帧所做的所有状态修改都将被回滚。

### 存储，主存和栈
每个帐户都有一个持久性内存区域，称为存储(storage)。其形式为key-value，key和value的长度均为256bits。在一个合约中，遍历账户的storage是不可能的，同时在合约中读取storage是开销很大的，而修改storage则更加是。一个合约只能对自己的storage进行读和写。

第二块内存区域叫做主存（memory），在每次消息调用时，一个合约都会获得一块新的被清洗过的memory。

Memory是线性的，并且可以在字节级寻址，但是读取被限制为256位宽，而写入可以是8位或256位宽。当访问（读或写）一个之前没有访问过的memory时，memory通过一个256位的指令进行扩展。扩展时需要花费gas。操作主存的开销随着其增长而变大（平方级别）。

EVM不是基于寄存器的，而是基于栈的虚拟机，因此所有的计算都运行于栈区。栈最大有1024个元素，每个元素256比特。对栈的访问只限于其顶端，方式为：允许拷贝最顶端的16个元素中的一个到栈顶，或者是交换栈顶元素和下面16个元素中的一个。所有其他操作都只能取最顶的两个（或一个，或更多，取决于具体的操作）元素，并把结果压在栈顶。当然可以把栈上的元素放到存储或者主存中。但是无法只访问栈上指定深度的那个元素，在那之前必须要把指定深度之上的所有元素都从栈中移除才行。

### 指令集
EVM的指令集被刻意保持在最小规模，以尽可能避免可能导致共识问题的错误实现。所有的指令都是基于256比特这个基本的数据类型的操作。可以进行常用的算术，位，逻辑和比较运算。也可以做到条件和无条件跳转。此外，合约可以访问当前区块的相关属性，比如它的编号和时间戳。

### 消息调用
合约可以通过消息调用的方式调用其他合约或者发送以太币到非合约账户。消息调用和事务是相似的，它们都有一个源，一个目标，数据负载，以太币，gas和返回数据。事实上每个事务都可以被认为是一个顶层消息调用，这个消息调又可以创建进一步的消息调用。

合约可以决定其剩余gas的分配，如果在内部调用时产生了out-of-gas异常（或者任何其他异常），他将被一个错误值标记然后压入到栈中。在这种情况下，只是内部消息调用的gas耗尽。在solidity中，在这样的情况下调用的合约会默认触发一个人工异常，以便异常弹出栈。

如上所述，被调用的合约（发起调用的合约也一样）会拥有崭新的主存并访问调用的负载，调用负载被存储在一个单独的被称为calldata的区域。调用执行结束后，返回数据将被存放在调用方预先分配好的一块内存中。

调用层数被限制为1024，这意味着对于更复杂的操作，循环应该优先于递归调用。

### 码调用和库
存在一个消息调用的特殊变体，名为delegatecall，它与消息调用一致，只是加载自目标地址的代码将在发起调用的合约上下文中运行并且`msg.sender` 和`msg.value`不会改变他们的值。

这意味着合同可以在运行时从不同的地址动态加载代码。存储，当前地址和余额都指向发起调用的合约，只有代码是从被调用地址获取的。

这使得在solidity中实现库的特征是可能的：可重复使用的库代码，可应用于合约的存储中，以便实现复杂的数据结构。

### 日志
可以将数据存储在专门索引的数据结构中，该数据结构将所有数据映射到区块级别。这个称为日志的功能被Solidity用于实现事件。合约在创建后无法访问日志数据，但可以从区块链外部有效访问日志数据。因为部分日志数据被存储在布隆过滤器（Bloom filter)中，我们可以高效并且安全的搜索日志，所以那些没有下载整个区块链的网络节点（轻客户端）也可以找到这些日志。

### 创建
合约甚至可以通过一个特殊的指令来创建另一个合约（不是简单的调用零地址）。这些创建调用和正常消息调用之间的唯一区别是，负载数据执行的结果被当作代码，调用者/创建者在栈上得到新合约的地址。

### 自毁
从区块链中删除代码的唯一可能性是该地址上的合约执行自毁操作。存储在该地址处的剩余以太币被发送到指定的目标，然后存储和代码从状态中移除。

警告，即使一个合约的代码不包含自毁指令，依然可以通过代码调用(callcode)来执行这个操作。

注意，旧合约的缩减可能或可能不由Ethereum客户端执行。此外，归档节点可以选择永久保持合约存储和代码。目前无法从状态中移除外部帐户。
