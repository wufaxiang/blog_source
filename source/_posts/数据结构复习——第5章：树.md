---
title: 数据结构复习——第5章：树
date: 2015-01-01 16:22:12
tags: 
  - 数据结构
  - Tree
category: 数据结构
---


** 1.树：是n个结点的有限集T，T为空时称空树，否则满足： **

** 1）有且仅有一个特定的称为根的结点； **

** 2）其余结点可分为m个互不相交的子集，每个子集本身是一棵树，并称为根的子树。 **

**   
**

** 2.树的表示方法： **

** 1）树形表示法； **

** 2）嵌套集合表示法； **

** 3）凹入表表示法； **

** 4）广义表表示法； **
<!-- more -->
**   
**

** 3.一个结点拥有的子树数称为该结点的度； **

** 一棵树的度是指树中结点最大的度数。 **

**   
**

** 4.度为零的结点称叶子或终端结点； **

** 度不为零的结点称分支结点或非终端结点 **

**   
**

** 5.根结点称开始结点，根结点外的分支结点称内部结点； **

**   
**

** 6.树中某结点的子树根称该结点的孩子； **

** 该结点称为孩子的双亲； **

**   
**

** 7.树中存在一个结点序列K1，K2，…Kn，使Ki为Ki+1的双亲，则称该结点序列为K1到Kn的路径或道路； **

**   
**

** 8.树中结点K到Ks间存在一条路径，则称K是Ks的祖先，Ks是K的子孙； **

**   
**

** 9.结点的层数从根算起，若根的层数为1，则其余结点层数是其双亲结点层数加1； **

** 双亲在同一层的结点互为堂兄弟； **

** 树中结点最大层数称为树的高度或深度； **

**   
**

** 10.树中每个结点的各个子树从左到右有次序的称有序树，否则称无序树； **

**   
**

** 11.森林是m棵互不相交的树的集合。 **

** **

** 12.二叉树：是n个结点的有限集，它或为空集，或由一个根结点及两棵互不相交的、分别称为该根的左子树和右子树的二叉树组成。 **

** 13.二叉树不是树的特殊情况，这是两种不同的数据结构；它与无序树和度为2的有序树不同。 **

** 14.二叉树的性质： **

** 1） 二叉树第i层上的结点数最多为2^(i-1)； **

** 2） 深度为k的二叉树至多有2^k-1个结点； **

** 3） 在任意二叉树中，叶子数为n0，度为2的结点数为n2，则n0=n2+1； **

** 15.满二叉树是一棵深度为k的且有2^k-1个结点的二叉树； **

** 16.完全二叉树是至多在最下两层上结点的度数可以小于2，并且最下层的结点集中在该层最左的位置的二叉树； **

** 17.具有N个结点的完全二叉树的深度为log2N取整加1； **

** 18.二叉树的存储结构 **

** （1）顺序存储结构：把一棵有n个结点的完全二叉树，从树根起自上而下、从左到右对所有结点编号，然后依次存储在一个向量b[0~n]中，b[1~n]存放结点，b[0]存放结点总数。 **

** 各个结点编号间的关系： **

** 1） i=1是根结点；i>1则双亲结点是i/2取整； **

** 2） 左孩子是2i, 右孩子是2i+1；（要小于n） **

** 3） i>（n/2取整）的结点是叶子； **

** 4） 奇数没有右兄弟，左兄弟是i-1； **

** 5） 偶数没有左兄弟，右兄弟是i+1； **

** （2）链式存储结构 **

** 结点的结构为：lchild|data|rchild ；相应的类型说明： **

** **
    
    
    typedef char data;
    typedef struct node{
     datatype data;
     structnode *lchild , *rchild;
    }bintnode;
    typedef bintnode * bintree;

**   
**

** 19.在二叉树中所有类型为bintnode的结点和一个指向开始结点的bintree类型的头指针构成二叉树的链式存储结构称二叉链表。 **

**   
**

** 20.二叉链表由根指针唯一确定。在n个结点的二叉链表中有2n个指针域，其中n+1个为空。 **

** **

** 21.二叉树的遍历方式有：前序遍历、中序遍历、后序遍历。时间复杂度为O(n)。 **

**   
**

** 22.线索二叉树：利用二叉链表中的n+1个空指针域存放指向某种遍历次序下的前趋和后继结点的指针，这种指针称线索。加线索的二叉链表称线索链表。相应二叉树称线索二叉树。 **

**   
**

** 23.线索链表结点结构：lchild|ltag|data|rtag|rchild；ltag=0,lchild是指向左孩子的指针；ltag=1,lchild是指向前趋的线索；rtag=0,rchild是指向右孩子的指针；rtag=1,rchild是指向后继的线索； **

**   
**

** 24.查找*p在指定次序下的前趋和后继结点。算法的时间复杂度为O(h)。线索对查找前序前趋和后序后继帮助不大。 **

**   
**

** 25.遍历线索二叉树。时间复杂度为O(n)。 **

** **

** 26.树、森林与二叉树的转换 **

** （1）树、森林与二叉树的转换 **

** 1）树与二叉树的转换： **

** 1}所有兄弟间连线； **

** 2}保留与长子的连线，去除其它连线。 **

** 该二叉树的根结点的右子树必为空。 **

** 2）森林与二叉树的转换： **

** 1}将所有树转换成二叉树； **

** 2}将所有树根连线。 **

** （2）二叉树与树、森林的转换。是以上的逆过程。 **

**   
**

** 27.树的存储结构 **

** （1）双亲链表表示法：为每个结点设置一个parent指针，就可唯一表示任何一棵树。Data|parent **

** （2）孩子链表表示法：为每个结点设置一个firstchild指针，指向孩子链表头指针，链表中存放孩子结点序号。Data|firstchild。 **

** （3）双亲孩子链表表示法：将以上方法结合。Data|parent|firstchild **

** （4）孩子兄弟链表表示法：附加两个指向左孩子和右兄弟的指针。Leftmostchild|data|rightsibling **

**   
**

** 28.树和森林的遍历：前序遍历一棵树等价于前序遍历对应二叉树；后序遍历等价于中序遍历对应二叉树。 **

** **

** 29.最优二叉树（哈夫曼树）：树的路径长度是从树根到每一结点的路径长度之和。将树中的结点赋予实数称为结点的权。 **

**   
**

** 30.结点的带权路径是该结点的路径长度与权的乘积。树的带权路径长度又称树的代价，是所有叶子的带权路径长度之和。 **

**   
**

** 31.带权路径长度最小的二叉树称最优二叉树（哈夫曼树）。 **

**   
**

** 32.具有2n-1个结点其中有n个叶子，并且没有度为1的分支结点的树称为严格二叉树。 **

**   
**

** 33.哈夫曼编码：  是一种编码方式，哈夫曼编码是可变  [ 字长  ](http://baike.baidu.com/view/731.htm) 编码(VLC)的一种。  **

**   
**

** 34.对字符集编码时，要求字符集中任一字符的编码都不是其它字符的编码前缀，这种编码称前缀码。 **

**   
**

** 35.字符出现频度与码长乘积之和称文件总长；字符出现概率与码长乘积之和称平均码长； **

**   
**

** 36.使文件总长或平均码长最小的前缀码称最优前缀码 **

**   
**

** 37.利用哈夫曼树求最优前缀码，左为0，右为1。编码平均码长最小；没有叶子是其它叶子的祖先，不可能出现重复前缀。 **

